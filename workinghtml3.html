<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolfram Alpha Short Answers API Test</title>
    <style>
    body {
        direction: rtl;
        font-family: 'Arial', sans-serif; /* A basic, readable font */
        background-color: #f5f5f5; /* A subtle background color */
        color: #333; /* Dark text for readability */
        margin: 0;
        padding: 2em;
    }
    h2 {
        text-align: center;
        color: #0077CC; /* A nice shade of blue */
    }
    form {
        max-width: 600px;
        margin: 2em auto;
        padding: 20px;
        background-color: #fff;
        box-shadow: 0 0 10px rgba(0,0,0,0.1); /* subtle shadow */
        border-radius: 10px;
    }
    label, button {
        display: block;
        margin-bottom: 10px;
    }
    button {
        padding: 10px 15px;
        background-color: #0077CC;
        border: none;
        color: #fff;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }
    button:hover {
        background-color: #005fa3;
    }
    .english {
        direction: ltr;
        unicode-bidi: embed;
    }
    p {
        max-width: 600px;
        margin: 20px auto;
        padding: 20px;
        background-color: #fff;
        box-shadow: 0 0 10px rgba(0,0,0,0.1); /* subtle shadow */
        border-radius: 10px;
    }
    img {
        max-width: 100%;
        display: block;
        margin: 2em auto;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    #loading {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.8);
    z-index: 1000;
	}

    .spinner {
        border: 6px solid #f3f3f3;
        border-top: 6px solid #0077CC;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
	</style>
    
</head>
<h2>חקירת פונקציה</h2>

<form id="queryForm">
    <label for="functionInput">הכנס פונקציה כאן (למשל, x^3 - 4x):</label>
    <input type="text" id="functionInput" class="english" required>
    <button type="submit">חקור פונקציה</button>
</form>
<div id="loading" style="display: none;">
    <div class="spinner"></div>
    <p>אנא המתן, מעבד נתונים...</p>
</div>
<p id="result"></p>
<img id="graph" alt="Graph Representation" style="display:none;"/>
<script>
    const form = document.getElementById('queryForm');
	const resultElement = document.getElementById('result');
	const loading = document.getElementById('loading');
	form.addEventListener('submit', async function(e) {
    e.preventDefault();
    loading.style.display = 'flex';  // Show the loading message

    const functionQuery = encodeURIComponent(document.getElementById('functionInput').value);

    try {
        const response = await fetch(`http://localhost:5000/getCriticalPoints?mathFunction=${functionQuery}`);
        const jsonResponse = await response.json();
        loading.style.display = 'none';  // Hide the loading message once fetch request is completed

        if (jsonResponse.error) {
            resultElement.textContent = 'Error: ' + jsonResponse.error;
        } else {
            let domainStr = `תחום:<br><span class="english" style="display: inline;"> ${parseDomain(jsonResponse.domain)}</span><br>`;
    		let extremePointsStr = 'נקודות קיצון:<br>';
        jsonResponse.extreme_points.extreme_points.forEach(point => {
            extremePointsStr += `נקודה: <span class="english" style="display: inline;">(${point.x},${point.y})</span>, סוג: <span class="english" style="display: inline;">${point.type}</span><br>`;
        });
        let increasingIntervals = `תחומי עלייה:<br> <span class="english" style="display: inline;">${parseIncreasingDecreasing(jsonResponse.increasing_decreasing_intervals.increasing_intervals)}</span><br>`;
        let decreasingIntervals = `תחומי ירידה:<br> <span class="english" style="display: inline;"> ${parseIncreasingDecreasing(jsonResponse.increasing_decreasing_intervals.decreasing_intervals)}</span><br>`;
        
        let horizontal_asymptote = jsonResponse.asymptotes.horizontal_asymptote !== "inf"? `אסימפטוטות אופקיות:<br> [y = ${jsonResponse.asymptotes.horizontal_asymptote}]`:`אסימפטוטות אופקיות:<br>[]`;
        let vertical_asymptotes = 'אסימפטוטות אנכיות: <br>';
        vertical_asymptotes+= `[`
        jsonResponse.asymptotes.vertical_asymptotes.forEach((point, index, array) => {
            vertical_asymptotes += `x = ${point}`;
                if (index < array.length - 1) {
                    vertical_asymptotes += ', ';
                }
            });
        vertical_asymptotes += `]`
        let inflection_points = 'נקודות פיתול:<br>'
        jsonResponse.inflection_points.inflection_points.forEach(point => {
            inflection_points += `נקודה: <span class="english" style="display: inline;">(${point.x},${point.y})</span><br>`;
        });
        let intersections_with_x = `נקודות חיתוך עם ציר ה-x:<br>`;
        intersections_with_x += `[`;
        jsonResponse.intersections_with_axes.with_x.forEach((point, index, array) => {
            intersections_with_x += `x = ${point.x}`;
            if(index < array.length - 1){
                intersections_with_x += `, `;
            } 
        });
        intersections_with_x += `]`;
        let intersections_with_y = `נקודות חיתוך עם ציר ה-y:<br>`;
        intersections_with_y += `[`;
        jsonResponse.intersections_with_axes.with_y.forEach(point => {
            intersections_with_y += `y = ${point.y}`;
        });
        intersections_with_y += `]`;
        
        
        resultElement.innerHTML = `<p>${domainStr} <br/> ${extremePointsStr} <br/> 
                                    ${increasingIntervals} <br/>${decreasingIntervals} <br/> 
                                    ${horizontal_asymptote}<br/><br/> ${vertical_asymptotes}<br/><br/> 
                                    ${inflection_points}<br/> ${intersections_with_x}<br/><br/> 
                                    ${intersections_with_y}</p>`;
        let graphImg = document.getElementById('graph');
        graphImg.src = 'data:image/png;base64,' + jsonResponse.graph_representation; 
        graphImg.style.display = 'block';
        }
    } catch (error) {
    	loading.style.display = 'none';
        console.error(error);
        resultElement.textContent = 'Error fetching results.';
    }
});
</script>
<script>
function parseDomain(domainStr) {
  if (domainStr.includes("Reals")) {
    return "all x";
  }

  const regexp = /Interval(?:\.open|\.Ropen|\.Lopen|\.Rclose|\.Lclose)?\((-oo|[\d\*\-pi]+),\s*(oo|[\d\*\-pi]+)\)/g;

  let match;
  let intervals = [];

  while ((match = regexp.exec(domainStr)) !== null) {
    const type = match[0].substring(9, match[0].indexOf("(")); // Extract the type (e.g., .Ropen, .open)
    const startValue = match[1];
    const endValue = match[2];

    let intervalStr;
    switch (type) {
      case "open":
        intervalStr = `${startValue} < x < ${endValue}`;
        break;
      case "Ropen":
        intervalStr = `${startValue} <= x < ${endValue}`;
        break;
      case "Lopen":
        intervalStr = `${startValue} < x <= ${endValue}`;
        break;
      case "Rclose": // This will probably be reverse but kept for clarity
        intervalStr = `${startValue} < x <= ${endValue}`;
        break;
      case "Lclose": // This will probably be reverse but kept for clarity
        intervalStr = `${startValue} <= x < ${endValue}`;
        break;
      default:
        intervalStr = `${startValue} <= x <= ${endValue}`;
        break;
    }
    intervals.push(intervalStr);
  }
  
  return intervals.join(", ");
}
function parseIncreasingDecreasing(intervals) {
    if (!Array.isArray(intervals)) {
        console.error("Expected an array, but received:", intervals);
        return '';
    }

    const formattedIntervals = intervals.map(intervalStr => {
        // Split the string to get the interval values
        const interval = intervalStr.replace(/[\[\]]/g, '').split(',');

        if (interval && interval.length === 2) {
            let start = interval[0];
            let end = interval[1];
            return `${start} < x < ${end}`;
        } else {
            console.error("Unexpected interval format:", intervalStr);
            return '';  // or some default string representation
        }
    });
    
    return formattedIntervals.join(", ");
}
</script>